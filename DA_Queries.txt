CREATE TABLE AppleStore_combined_table AS
SELECT * FROM appleStore_description1
UNION ALL 
SELECT * FROM appleStore_description2
UNION ALL 
SELECT * FROM appleStore_description3
union all 
SELECT * FROM appleStore_description4
**EXPLORATORY DATA ANALYSIS**

--check the number of unique apps in both tablesAppleStore
SELECT COUNT(DISTINCT id) AS UniqueAPPid FROM AppleStore;
SELECT COUNT(DISTINCT id) AS UniqueAPPid FROM AppleStore_combined_table;

--same values, so there are no missing values
--check messing values in key fields 
SELECT COUNT(*) FROM AppleStore WHERE track_name IS NULL OR user_rating IS NULL OR prime_genre IS NULL;

SELECT COUNT(*) FROM AppleStore_combined_table WHERE id IS NULL OR track_name IS NULL OR app_desc IS NULL;

--Let's find out the number of apps per genre 

SELECT prime_genre, COUNT(*) total FROM AppleStore GROUP BY prime_genre ORDER BY total DESC

--Get an overview of app rating
SELECT MIN(user_rating) AS Minimum_rating, MAX(user_rating) AS Maximum_rating, ROUND(AVG(user_rating),2) AS Average_rating FROM AppleStore;

**DATA ANALYSIS**

--Determine Wether paid apps have higher rating than free appsAppleStore
SELECT CASE
			WHEN price > 0 THEN "paid"
            ELSE "Free"
       end AS App_type,
       ROUND(AVG(user_rating),2) AS user_average_rating
FROM AppleStore
GROUP BY App_type;

--check if app with more supported languages have higher rating
SELECT CASE
			WHEN lang_num < 10 THEN "<10 lang"
            WHEN lang_num BETWEEN 10 AND 30 THEN "10<lang<30"
            ELSE "more than 30"
         END AS number_of_languages,
         ROUND(AVG(user_rating),2) AS user_average_rating
FROM AppleStore
GROUP BY number_of_languages
ORDER BY user_average_rating DESC;
--check genres with lower rating
SELECT prime_genre, ROUND(AVG(user_rating),2) AS average_rating_by_genre
FROM AppleStore
GROUP BY prime_genre
ORDER BY average_rating_by_genre ASC;

--check if there is any correlation between the app description and user rating 
SELECT CASE
			WHEN LENGTH(B.app_desc) < 500 THEN "short"
            WHEN LENGTH(B.app_desc) BETWEEN 500 AND 1000 THEN "medium"
            ELSE "long"
           END AS text_size,
           ROUND(AVG(A.user_rating),2) AS average_rating_text
FROM AppleStore A 
JOIN AppleStore_combined_table B 
ON A.id=B.id
GROUP BY text_size
ORDER BY average_rating_text DESC;

--check the top rated apps for each genre
SELECT
	prime_genre,
    track_name,
    user_rating
FROM (
  	  SELECT
       prime_genre,
       track_name,
       user_rating,
       RANK() OVER(PARTITION BY prime_genre ORDER BY user_rating DESC, rating_count_tot DESC) As rank
       FROM
       AppleStore
    )  AS a
 WHERE
 a.rank = 1